"""
Service functions for Resource persistence and linking in Neo4j.

Resources represent media attachments (images, PDFs, audio, links, etc.)
that can be associated with concepts via HAS_RESOURCE relationships.
"""

from typing import List, Optional
from neo4j import Session
from uuid import uuid4

from models import Resource

RESOURCE_LABEL = "Resource"


def create_resource(
    session: Session,
    *,
    kind: str,
    url: str,
    title: Optional[str] = None,
    mime_type: Optional[str] = None,
    caption: Optional[str] = None,
    source: Optional[str] = None,
) -> Resource:
    """
    Create a Resource node in Neo4j and return it as a Resource model.
    
    The resource_id is generated as a UUID string.
    Caption can be automatically generated by AI (see services_resource_ai.py):
    - Images: GPT-4 Vision generates descriptive captions
    - PDFs: Text extraction + LLM summarization
    """
    resource_id = f"R{uuid4().hex[:8].upper()}"
    
    query = f"""
    CREATE (r:{RESOURCE_LABEL} {{
        resource_id: $resource_id,
        kind: $kind,
        url: $url,
        title: $title,
        mime_type: $mime_type,
        caption: $caption,
        source: $source
    }})
    RETURN r
    """
    result = session.run(
        query,
        resource_id=resource_id,
        kind=kind,
        url=url,
        title=title,
        mime_type=mime_type,
        caption=caption,
        source=source,
    )
    record = result.single()
    if not record:
        raise ValueError("Failed to create resource")
    node = record["r"]
    return Resource(
        resource_id=node["resource_id"],
        kind=node["kind"],
        url=node["url"],
        title=node.get("title"),
        mime_type=node.get("mime_type"),
        caption=node.get("caption"),
        source=node.get("source"),
    )


def get_resource_by_id(session: Session, resource_id: str) -> Optional[Resource]:
    """
    Fetch a Resource by its resource_id.
    """
    query = f"""
    MATCH (r:{RESOURCE_LABEL} {{resource_id: $resource_id}})
    RETURN r
    """
    result = session.run(query, resource_id=resource_id)
    record = result.single()
    if not record:
        return None
    node = record["r"]
    return Resource(
        resource_id=node["resource_id"],
        kind=node["kind"],
        url=node["url"],
        title=node.get("title"),
        mime_type=node.get("mime_type"),
        caption=node.get("caption"),
        source=node.get("source"),
    )


def link_resource_to_concept(
    session: Session,
    *,
    concept_id: str,
    resource_id: str,
) -> None:
    """
    Create a HAS_RESOURCE relationship between a Concept and a Resource.
    """
    query = """
    MATCH (c:Concept {node_id: $concept_id})
    MATCH (r:Resource {resource_id: $resource_id})
    MERGE (c)-[rel:HAS_RESOURCE]->(r)
    """
    session.run(query, concept_id=concept_id, resource_id=resource_id)


def get_resources_for_concept(
    session: Session,
    concept_id: str,
) -> List[Resource]:
    """
    Return all Resource nodes attached to a Concept via HAS_RESOURCE.
    """
    query = f"""
    MATCH (c:Concept {{node_id: $concept_id}})-[:HAS_RESOURCE]->(r:{RESOURCE_LABEL})
    RETURN r
    ORDER BY r.title
    """
    result = session.run(query, concept_id=concept_id)
    resources: List[Resource] = []
    for record in result:
        node = record["r"]
        resources.append(
            Resource(
                resource_id=node["resource_id"],
                kind=node["kind"],
                url=node["url"],
                title=node.get("title"),
                mime_type=node.get("mime_type"),
                caption=node.get("caption"),
                source=node.get("source"),
            )
        )
    return resources
