"""
Service functions for Resource persistence and linking in Neo4j.

Resources represent media attachments (images, PDFs, audio, links, etc.)
that can be associated with concepts via HAS_RESOURCE relationships.
"""

from typing import List, Optional, Dict, Any
from neo4j import Session
from uuid import uuid4
from datetime import datetime
import json

from models import Resource

RESOURCE_LABEL = "Resource"


def create_resource(
    session: Session,
    *,
    kind: str,
    url: str,
    title: Optional[str] = None,
    mime_type: Optional[str] = None,
    caption: Optional[str] = None,
    source: Optional[str] = None,
    metadata: Optional[Dict[str, Any]] = None,
    ingestion_run_id: Optional[str] = None,
) -> Resource:
    """
    Create a Resource node in Neo4j and return it as a Resource model.
    
    The resource_id is generated as a UUID string.
    Caption can be automatically generated by AI (see services_resource_ai.py):
    - Images: GPT-4 Vision generates descriptive captions
    - PDFs: Text extraction + LLM summarization
    
    Metadata is stored as a JSON string in Neo4j for compatibility.
    """
    resource_id = f"R{uuid4().hex[:8].upper()}"
    metadata_json = json.dumps(metadata) if metadata else None
    created_at = datetime.utcnow().isoformat()
    
    query = f"""
    CREATE (r:{RESOURCE_LABEL} {{
        resource_id: $resource_id,
        kind: $kind,
        url: $url,
        title: $title,
        mime_type: $mime_type,
        caption: $caption,
        source: $source,
        metadata_json: $metadata_json,
        created_at: $created_at,
        ingestion_run_id: $ingestion_run_id
    }})
    RETURN r
    """
    result = session.run(
        query,
        resource_id=resource_id,
        kind=kind,
        url=url,
        title=title,
        mime_type=mime_type,
        caption=caption,
        source=source,
        metadata_json=metadata_json,
        created_at=created_at,
        ingestion_run_id=ingestion_run_id,
    )
    record = result.single()
    if not record:
        raise ValueError("Failed to create resource")
    node = record["r"]
    # Parse metadata_json back to dict if it exists
    metadata_dict = None
    if node.get("metadata_json"):
        try:
            metadata_dict = json.loads(node["metadata_json"])
        except (json.JSONDecodeError, TypeError):
            metadata_dict = None
    
    # Get created_at, handling both string and Neo4j DateTime objects
    created_at = node.get("created_at")
    if created_at:
        if hasattr(created_at, 'to_native'):
            # Convert Neo4j DateTime to Python datetime, then to ISO string
            created_at = created_at.to_native().isoformat()
        elif isinstance(created_at, datetime):
            created_at = created_at.isoformat()
        elif not isinstance(created_at, str):
            created_at = str(created_at)
    
    return Resource(
        resource_id=node["resource_id"],
        kind=node["kind"],
        url=node["url"],
        title=node.get("title"),
        mime_type=node.get("mime_type"),
        caption=node.get("caption"),
        source=node.get("source"),
        metadata=metadata_dict,
        created_at=created_at,
        ingestion_run_id=node.get("ingestion_run_id"),
    )


def get_resource_by_id(session: Session, resource_id: str, include_archived: bool = False) -> Optional[Resource]:
    """
    Fetch a Resource by its resource_id.
    """
    where_clause = ""
    if not include_archived:
        where_clause = "WHERE COALESCE(r.archived, false) = false"
    
    query = f"""
    MATCH (r:{RESOURCE_LABEL} {{resource_id: $resource_id}})
    {where_clause}
    RETURN r
    """
    result = session.run(query, resource_id=resource_id)
    record = result.single()
    if not record:
        return None
    node = record["r"]
    # Parse metadata_json back to dict if it exists
    metadata_dict = None
    if node.get("metadata_json"):
        try:
            metadata_dict = json.loads(node["metadata_json"])
        except (json.JSONDecodeError, TypeError):
            metadata_dict = None
    
    # Get created_at, handling both string and Neo4j DateTime objects
    created_at = node.get("created_at")
    if created_at:
        if hasattr(created_at, 'to_native'):
            # Convert Neo4j DateTime to Python datetime, then to ISO string
            created_at = created_at.to_native().isoformat()
        elif isinstance(created_at, datetime):
            created_at = created_at.isoformat()
        elif not isinstance(created_at, str):
            created_at = str(created_at)
    
    return Resource(
        resource_id=node["resource_id"],
        kind=node["kind"],
        url=node["url"],
        title=node.get("title"),
        mime_type=node.get("mime_type"),
        caption=node.get("caption"),
        source=node.get("source"),
        metadata=metadata_dict,
        created_at=created_at,
        ingestion_run_id=node.get("ingestion_run_id"),
    )


def link_resource_to_concept(
    session: Session,
    *,
    concept_id: str,
    resource_id: str,
) -> None:
    """
    Create a HAS_RESOURCE relationship between a Concept and a Resource.
    """
    query = """
    MATCH (c:Concept {node_id: $concept_id})
    MATCH (r:Resource {resource_id: $resource_id})
    MERGE (c)-[rel:HAS_RESOURCE]->(r)
    """
    session.run(query, concept_id=concept_id, resource_id=resource_id)


def get_resources_for_concept(
    session: Session,
    concept_id: str,
    include_archived: bool = False,
) -> List[Resource]:
    """
    Return all Resource nodes attached to a Concept via HAS_RESOURCE.
    """
    where_clause = ""
    if not include_archived:
        where_clause = "WHERE COALESCE(r.archived, false) = false"
    
    query = f"""
    MATCH (c:Concept {{node_id: $concept_id}})-[:HAS_RESOURCE]->(r:{RESOURCE_LABEL})
    {where_clause}
    RETURN r
    ORDER BY r.title
    """
    result = session.run(query, concept_id=concept_id)
    resources: List[Resource] = []
    for record in result:
        node = record["r"]
        # Parse metadata_json back to dict if it exists
        metadata_dict = None
        if node.get("metadata_json"):
            try:
                metadata_dict = json.loads(node["metadata_json"])
            except (json.JSONDecodeError, TypeError):
                metadata_dict = None
        # Get created_at, handling both string and Neo4j DateTime objects
        created_at = node.get("created_at")
        if created_at:
            if hasattr(created_at, 'to_native'):
                # Convert Neo4j DateTime to Python datetime, then to ISO string
                created_at = created_at.to_native().isoformat()
            elif isinstance(created_at, datetime):
                created_at = created_at.isoformat()
            elif not isinstance(created_at, str):
                created_at = str(created_at)
        
        resources.append(
            Resource(
                resource_id=node["resource_id"],
                kind=node["kind"],
                url=node["url"],
                title=node.get("title"),
                mime_type=node.get("mime_type"),
                caption=node.get("caption"),
                source=node.get("source"),
                metadata=metadata_dict,
                created_at=created_at,
                ingestion_run_id=node.get("ingestion_run_id"),
            )
        )
    return resources


def search_resources(
    session: Session,
    query: str,
    graph_id: Optional[str] = None,
    limit: int = 20,
    include_archived: bool = False,
) -> List[Resource]:
    """
    Search for resources by title or caption (case-insensitive partial match).
    Optionally filter by graph_id if resources are linked to concepts in that graph.
    """
    where_clauses = []
    params: Dict[str, Any] = {
        "query": query.lower(),
        "limit": limit,
    }
    
    if not include_archived:
        where_clauses.append("COALESCE(r.archived, false) = false")
    
    # Build query - search in title and caption
    base_query = f"""
    MATCH (r:{RESOURCE_LABEL})
    """
    
    # If graph_id is provided, filter by concepts in that graph
    return_concept_id = True
    if graph_id:
        from services_branch_explorer import set_active_graph, ensure_graph_scoping_initialized, get_active_graph_context
        set_active_graph(session, graph_id)
        ensure_graph_scoping_initialized(session)
        graph_id_ctx, branch_id = get_active_graph_context(session)
        if graph_id_ctx == graph_id:
            base_query = f"""
            MATCH (c:Concept)-[:HAS_RESOURCE]->(r:{RESOURCE_LABEL})
            WHERE $branch_id IN COALESCE(c.on_branches, [])
            WITH r, collect(DISTINCT c.node_id)[0] as concept_id
            """
            params["branch_id"] = branch_id
        else:
            # Graph not found, return empty
            return []
    else:
        # Without graph_id, still try to get concept_id if linked
        base_query = f"""
        OPTIONAL MATCH (c:Concept)-[:HAS_RESOURCE]->(r:{RESOURCE_LABEL})
        WITH r, collect(DISTINCT c.node_id)[0] as concept_id
        """
    
    where_clauses.append(
        "(toLower(COALESCE(r.title, '')) CONTAINS $query OR toLower(COALESCE(r.caption, '')) CONTAINS $query)"
    )
    
    where_clause = " AND ".join(where_clauses) if where_clauses else ""
    if where_clause:
        base_query += f" AND {where_clause}"
    
    base_query += """
    RETURN r, COALESCE(r.title, '') as title_sort, concept_id
    ORDER BY title_sort
    LIMIT $limit
    """
    
    result = session.run(base_query, **params)
    resources: List[Resource] = []
    concept_ids: Dict[str, Optional[str]] = {}
    
    for record in result:
        node = record["r"]
        if not node:
            continue
            
        # Store concept_id if available
        if return_concept_id:
            concept_id = record.get("concept_id")
            if concept_id:
                concept_ids[node["resource_id"]] = concept_id
        
        # Parse metadata_json back to dict if it exists
        metadata_dict = None
        if node.get("metadata_json"):
            try:
                metadata_dict = json.loads(node["metadata_json"])
            except (json.JSONDecodeError, TypeError):
                metadata_dict = None
        # Get created_at, handling both string and Neo4j DateTime objects
        created_at = node.get("created_at")
        if created_at:
            if hasattr(created_at, 'to_native'):
                created_at = created_at.to_native().isoformat()
            elif isinstance(created_at, datetime):
                created_at = created_at.isoformat()
            elif not isinstance(created_at, str):
                created_at = str(created_at)
        
        resources.append(
            Resource(
                resource_id=node["resource_id"],
                kind=node["kind"],
                url=node["url"],
                title=node.get("title"),
                mime_type=node.get("mime_type"),
                caption=node.get("caption"),
                source=node.get("source"),
                metadata=metadata_dict,
                created_at=created_at,
                ingestion_run_id=node.get("ingestion_run_id"),
            )
        )
    
    # Store concept_ids in metadata for frontend access
    # Note: This is a workaround since Resource model doesn't have concept_id field
    # Frontend can extract it from metadata if needed
    for resource in resources:
        if resource.resource_id in concept_ids:
            if not resource.metadata:
                resource.metadata = {}
            resource.metadata['_concept_id'] = concept_ids[resource.resource_id]
    
    return resources
